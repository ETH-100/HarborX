<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HarborX SQL Demo</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;max-width:1100px;margin:32px auto;padding:0 16px}
    textarea{width:100%;min-height:160px;font-family:ui-monospace,Consolas,monospace;font-size:14px}
    table{border-collapse:collapse;width:100%;margin-top:12px}
    th,td{border:1px solid #ddd;padding:6px 8px;font-size:13px}
    th{background:#f5f5f5;text-align:left}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .muted{color:#666}
    .btn{padding:8px 14px;border:1px solid #ccc;background:#fff;border-radius:6px;cursor:pointer}
    .btn:hover{background:#f7f7f7}
    .pill{padding:4px 8px;border-radius:999px;background:#f0f0f0}
    .error{color:#b00020}
    .mono{font-family:ui-monospace,Consolas,monospace}
  </style>
</head>
<body>
  <h1>HarborX SQL Demo</h1>
  <p class="muted">Run SQL against <b>Arrow (DuckDB)</b> or <b>SQLite</b> built from your latest benchmark run.</p>

  <div class="row" style="margin:12px 0">
    <label>Engine:</label>
    <select id="engine">
      <option value="arrow_bridge">Arrow (DuckDB bridge)</option>
      <option value="arrow_ext">Arrow (DuckDB ext)</option>
      <option value="sqlite">SQLite</option>
    </select>
    <span id="status" class="pill">Idle</span>
  </div>

  <div class="row">
    <label>Examples:</label>
    <select id="examples">
      <option value="">-- choose --</option>
      <option value="SELECT COUNT(*) AS rows FROM state;">COUNT rows (state)</option>
      <option value="SELECT key, MAX(timestamp) AS ts FROM state GROUP BY key LIMIT 100;">LWW per key (LIMIT 100)</option>
      <option value="WITH ranked AS ( SELECT key, value, timestamp, blob_index, position, ROW_NUMBER() OVER (PARTITION BY key ORDER BY timestamp DESC, blob_index DESC, position DESC) AS rn FROM state ) SELECT COUNT(*) AS unique_keys FROM ranked WHERE rn=1;">LWW count (window)</option>
    </select>
    <button class="btn" id="fill">Insert</button>
  </div>

  <textarea id="sql" placeholder="Write your SQL here..."></textarea>
  <div class="row" style="margin-top:8px">
    <button class="btn" id="run">Run</button>
    <span class="muted">Result rows are fully returned; for huge outputs, add LIMIT.</span>
  </div>

  <p id="meta" class="muted"></p>
  <div id="error" class="error"></div>
  <div id="result"></div>

  <script>
    const el = (id) => document.getElementById(id);
    const status = el('status');

    el('fill').onclick = () => {
      const q = el('examples').value; if (q) el('sql').value = q;
    };

    el('run').onclick = async () => {
      const engine = el('engine').value;
      const sql = el('sql').value.trim();
      el('error').textContent = '';
      el('meta').textContent = '';
      el('result').innerHTML = '';
      if (!sql) { el('error').textContent = 'SQL is empty'; return; }

      status.textContent = 'Running...';
      status.style.background = '#e8eefc';
      const t0 = performance.now();
      try {
        const res = await fetch('/api/query', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ engine, sql })
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data?.detail || res.statusText);
        const dt = (performance.now() - t0).toFixed(1);

        el('meta').innerHTML = `Rows: <b>${data.row_count}</b> · Engine: <span class="mono">${engine}</span> · Server: <b>${data.elapsed_ms} ms</b> · Roundtrip: <b>${dt} ms</b>`;

        // Render table
        const cols = data.columns || [];
        const rows = data.rows || [];
        const tbl = document.createElement('table');
        const thead = document.createElement('thead');
        const trh = document.createElement('tr');
        cols.forEach(c => { const th = document.createElement('th'); th.textContent = c; trh.appendChild(th); });
        thead.appendChild(trh); tbl.appendChild(thead);
        const tbody = document.createElement('tbody');
        rows.forEach(r => { const tr = document.createElement('tr'); r.forEach(v => { const td = document.createElement('td'); td.textContent = (v === null || v === undefined) ? '' : String(v); tr.appendChild(td); }); tbody.appendChild(tr); });
        tbl.appendChild(tbody);
        el('result').appendChild(tbl);
      } catch (err) {
        el('error').textContent = String(err.message || err);
      } finally {
        status.textContent = 'Idle';
        status.style.background = '#f0f0f0';
      }
    };
  </script>
</body>
</html>